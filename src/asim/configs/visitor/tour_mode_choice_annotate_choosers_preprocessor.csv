Description,Target,Expression,
#,,,
local,_DF_IS_TOUR,'tour_type' in df.columns,
#,,,
tour purpose,purpose_id,tours.loc[df.index]['purpose_id'],
is work tour,is_work,"np.where(purpose_id==0,1,0)",
is recreation tour,is_recreation,"np.where(purpose_id==1,1,0)",
is dining tour,is_dining,"np.where(purpose_id==2,1,0)",
auto availability,autoAvailable,tours.loc[df.index]['auto_available'],
income,income,tours.loc[df.index]['income'],
# demographic segment (0-1 = low / 2-4 = high),demographic_segment,,
,number_of_participants,df.number_of_participants if _DF_IS_TOUR else 1,
treat tours as work if tour_type not yet decided,tour_type,"df.get('tour_type', default='work')",
treat personal as default segment,segment,"df.get('segment', default='personal')",
#,,,
mandatory tour type boolean,is_mandatory,(df.tour_category=='mandatory') if 'tour_category' in df.columns else False,
# FIXME no transit subzones for ONE_ZONE version, so all zones short walk to transit,,
,_origin_distance_to_transit,"reindex(land_use.access_dist_transit, df[orig_col_name]) if 'access_dist_transit' in land_use else shortWalk",
,_destination_distance_to_transit,"reindex(land_use.access_dist_transit, df[dest_col_name]) if 'access_dist_transit' in land_use else shortWalk",
,walk_transit_available,(_origin_distance_to_transit > 0) & (_destination_distance_to_transit > 0),
,drive_transit_available,(_destination_distance_to_transit > 0) & (autoAvailable),
,origin_walk_time,_origin_distance_to_transit*60/walkSpeed,
,destination_walk_time,_destination_distance_to_transit*60/walkSpeed,
# RIDEHAIL,,,
household_density calculated in annotate_landuse in acres and is converted to sq miles here,origin_density_measure,"reindex(land_use.household_density, df[orig_col_name]) / 640",
employment_density calculated in annotate_landuse in acres and is converted to sq miles here,dest_density_measure,"reindex(land_use.employment_density, df[dest_col_name]) / 640",
,origin_density,"pd.cut(origin_density_measure, bins=[-np.inf] + wait_time_distribution_by_density_breaks + [np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,dest_density,"pd.cut(dest_density_measure, bins=[-np.inf] + wait_time_distribution_by_density_breaks + [np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,origin_zone_taxi_wait_time_mean,"origin_density.map({k: v for k, v in Taxi_waitTime_mean.items()})",
,origin_zone_taxi_wait_time_sd,"origin_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
,dest_zone_taxi_wait_time_mean,"dest_density.map({k: v for k, v in Taxi_waitTime_mean.items()})",
,dest_zone_taxi_wait_time_sd,"dest_density.map({k: v for k, v in Taxi_waitTime_sd.items()})", but of the underlying normal distribution it is derived from
# ,, Note that the mean and standard deviation are not the values for the distribution itself,
,origTaxiWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_taxi_wait_time_mean, sigma=origin_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destTaxiWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_taxi_wait_time_mean, sigma=dest_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_singleTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,origin_zone_singleTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,dest_zone_singleTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,dest_zone_singleTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,origSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_singleTNC_wait_time_mean, sigma=origin_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_singleTNC_wait_time_mean, sigma=dest_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_sharedTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,origin_zone_sharedTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,dest_zone_sharedTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,dest_zone_sharedTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,origSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_sharedTNC_wait_time_mean, sigma=origin_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_sharedTNC_wait_time_mean, sigma=dest_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,totalWaitTaxi,origTaxiWaitTime + destTaxiWaitTime,
,totalWaitSingleTNC,origSingleTNCWaitTime + destSingleTNCWaitTime,
,totalWaitSharedTNC,origSharedTNCWaitTime + destSharedTNCWaitTime,
#,,,
,_free_parking_available,(tour_type == 'work') & df.free_parking_at_work if _DF_IS_TOUR else False,
,_dest_hourly_peak_parking_cost,"reindex(land_use.exp_hourly, df[dest_col_name])",
,_dest_hourly_offpeak_parking_cost,"reindex(land_use.exp_hourly, df[dest_col_name])",
,_hourly_peak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_peak_parking_cost)",
,_hourly_offpeak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_offpeak_parking_cost)",
,daily_parking_cost,"np.where(is_mandatory, _hourly_peak_parking_cost * df.duration, _hourly_offpeak_parking_cost * df.duration)",
# cost coef,,,
cost by income level,coef_cost,"np.select([income == 0, income == 1, income == 2, income > 2], [coef_cost_low, coef_cost_med, coef_cost_high, coef_cost_vhigh])",
#,,,
,vot_da,coef_ivt / coef_cost * 0.6,
no cost sharing for visitors,vot_s2,vot_da,
no cost sharing for visitors,vot_s3,vot_da,
,_vot_bin_da,"np.where(vot_da < vot_threshold_low, 1, np.where(vot_da < vot_threshold_med, 2, 3))",
,_vot_bin_s2,"np.where(vot_s2 < vot_threshold_low, 1, np.where(vot_s2 < vot_threshold_med, 2, 3))",
,_vot_bin_s3,"np.where(vot_s3 < vot_threshold_low, 1, np.where(vot_s3 < vot_threshold_med, 2, 3))",
# vot-indexed skims,,,
# assume no visitor transponder,,,
,da_dist_skims_out,(odt_skims['SOV_NT_L_DIST'] * (_vot_bin_da == 1)) + (odt_skims['SOV_NT_M_DIST'] * (_vot_bin_da == 2)) + (odt_skims['SOV_NT_H_DIST'] * (_vot_bin_da == 3)),
,da_dist_skims_inb,(dot_skims['SOV_NT_L_DIST'] * (_vot_bin_da == 1)) + (dot_skims['SOV_NT_M_DIST'] * (_vot_bin_da == 2)) + (dot_skims['SOV_NT_H_DIST'] * (_vot_bin_da == 3)),
,da_cost_skims_out,(odt_skims['SOV_NT_L_TOLLCOST'] * (_vot_bin_da == 1)) + (odt_skims['SOV_NT_M_TOLLCOST'] * (_vot_bin_da == 2)) + (odt_skims['SOV_NT_H_TOLLCOST'] * (_vot_bin_da == 3)),
,da_cost_skims_inb,(dot_skims['SOV_NT_L_TOLLCOST'] * (_vot_bin_da == 1)) + (dot_skims['SOV_NT_M_TOLLCOST'] * (_vot_bin_da == 2)) + (dot_skims['SOV_NT_H_TOLLCOST'] * (_vot_bin_da == 3)),
,da_time_skims_out,(odt_skims['SOV_NT_L_TIME'] * (_vot_bin_da == 1)) + (odt_skims['SOV_NT_M_TIME'] * (_vot_bin_da == 2)) + (odt_skims['SOV_NT_H_TIME'] * (_vot_bin_da == 3)),
,da_time_skims_inb,(dot_skims['SOV_NT_L_TIME'] * (_vot_bin_da == 1)) + (dot_skims['SOV_NT_M_TIME'] * (_vot_bin_da == 2)) + (dot_skims['SOV_NT_H_TIME'] * (_vot_bin_da == 3)),
,da_rel_skims_out,(((odt_skims['SOV_NT_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['SOV_NT_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['SOV_NT_H_REL']) * (_vot_bin_da == 3))),
,da_rel_skims_inb,(((dot_skims['SOV_NT_L_REL']) * (_vot_bin_da == 1)) + ((dot_skims['SOV_NT_M_REL']) * (_vot_bin_da == 2)) + ((dot_skims['SOV_NT_H_REL']) * (_vot_bin_da == 3))),
,s2_dist_skims_out,(((odt_skims['HOV2_L_DIST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_DIST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_DIST']) * (_vot_bin_s2 == 3))),
,s2_dist_skims_inb,(((dot_skims['HOV2_L_DIST']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV2_M_DIST']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV2_H_DIST']) * (_vot_bin_s2 == 3))),
,s2_cost_skims_out,(((odt_skims['HOV2_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s2_cost_skims_inb,(((dot_skims['HOV2_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV2_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV2_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s2_time_skims_out,(((odt_skims['HOV2_L_TIME']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_TIME']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_TIME']) * (_vot_bin_s2 == 3))),
,s2_time_skims_inb,(((dot_skims['HOV2_L_TIME']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV2_M_TIME']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV2_H_TIME']) * (_vot_bin_s2 == 3))),
,s2_rel_skims_out,(((odt_skims['HOV2_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['HOV2_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['HOV2_H_REL']) * (_vot_bin_da == 3))),
,s2_rel_skims_inb,(((dot_skims['HOV2_L_REL']) * (_vot_bin_da == 1)) + ((dot_skims['HOV2_M_REL']) * (_vot_bin_da == 2)) + ((dot_skims['HOV2_H_REL']) * (_vot_bin_da == 3))),
,s3_dist_skims_out,(((odt_skims['HOV3_L_DIST']) * (_vot_bin_s3 == 1)) + ((odt_skims['HOV3_M_DIST']) * (_vot_bin_s3 == 2)) + ((odt_skims['HOV3_H_DIST']) * (_vot_bin_s3 == 3))),
,s3_dist_skims_inb,(((dot_skims['HOV3_L_DIST']) * (_vot_bin_s3 == 1)) + ((dot_skims['HOV3_M_DIST']) * (_vot_bin_s3 == 2)) + ((dot_skims['HOV3_H_DIST']) * (_vot_bin_s3 == 3))),
,Joint - Walk ASC - Auto sufficient,(((dot_skims['HOV3_L_DIST']) * (_vot_bin_s3 == 1)) + ((dot_skims['HOV3_M_DIST']) * (_vot_bin_s3 == 2)) + ((dot_skims['HOV3_H_DIST']) * (_vot_bin_s3 == 3))),
,s3_cost_skims_out,(((odt_skims['HOV3_L_TOLLCOST']) * (_vot_bin_s3 == 1)) + ((odt_skims['HOV3_M_TOLLCOST']) * (_vot_bin_s3 == 2)) + ((odt_skims['HOV3_H_TOLLCOST']) * (_vot_bin_s3 == 3))),
,s3_cost_skims_inb,(((dot_skims['HOV3_L_TOLLCOST']) * (_vot_bin_s3 == 1)) + ((dot_skims['HOV3_M_TOLLCOST']) * (_vot_bin_s3 == 2)) + ((dot_skims['HOV3_H_TOLLCOST']) * (_vot_bin_s3 == 3))),
,s3_time_skims_out,(((odt_skims['HOV3_L_TIME']) * (_vot_bin_s3 == 1)) + ((odt_skims['HOV3_M_TIME']) * (_vot_bin_s3 == 2)) + ((odt_skims['HOV3_H_TIME']) * (_vot_bin_s3 == 3))),
,s3_time_skims_inb,(((dot_skims['HOV3_L_TIME']) * (_vot_bin_s3 == 1)) + ((dot_skims['HOV3_M_TIME']) * (_vot_bin_s3 == 2)) + ((dot_skims['HOV3_H_TIME']) * (_vot_bin_s3 == 3))),
,s3_rel_skims_out,(((odt_skims['HOV3_L_REL']) * (_vot_bin_s3 == 1)) + ((odt_skims['HOV3_M_REL']) * (_vot_bin_s3 == 2)) + ((odt_skims['HOV3_H_REL']) * (_vot_bin_s3 == 3))),
,s3_rel_skims_inb,(((dot_skims['HOV3_L_REL']) * (_vot_bin_s3 == 1)) + ((dot_skims['HOV3_M_REL']) * (_vot_bin_s3 == 2)) + ((dot_skims['HOV3_H_REL']) * (_vot_bin_s3 == 3))),
#,,,
Use AV coefficients for tour,useAV,AV_OWNERSHIP_TARGET_PERCENT>0
Auto IVT Factor,autoIVTFactor,"np.where(useAV,autoIVTFactorAV,1)"
Auto Parking Cost Factor,autoParkingCostFactor,"np.where(useAV,autoParkingCostFactorAV,1)"
Auto CPM Factor,autoCPMFactor,"np.where(useAV,autoCostPerMileFactorAV,1)"
Auto Terminal Time Factor,autoTermTimeFactor,"np.where(useAV,autoTerminalTimeFactorAV,1)"
#,,,
Determining Tour Origin,origin,df.origin if 'origin' in df.columns else df.home_zone_id if 'home_zone_id' in df.columns else df.workplace_zone_id,
Determining Tour Destination,destination,df.destination if 'destination' in df.columns else df.alt_dest,
Origin MGRA Dwelling Unit Density,oMGRADUDen,"reindex(land_use.household_density,origin)",
Origin MGRA Employment Density,oMGRAEmpDen,"reindex(land_use.employment_density,origin)",
Origin MGRA Total Intersections,oMGRATotInt,"reindex(land_use.totint,origin)",
Destination MGRA Dwelling Unit Density,dMGRADUDen,"reindex(land_use.household_density,destination)",
Destination MGRA Employment Density,dMGRAEmpDen,"reindex(land_use.employment_density,destination)",
Destination MGRA Total Intersections,dMGRATotInt,"reindex(land_use.totint,destination)",
Origin MGRA Mix,oMGRAMix,"np.where(oMGRADUDen+oMGRAEmpDen > 0, (oMGRADUDen*oMGRAEmpDen)/(oMGRADUDen+oMGRAEmpDen),0)",
Destination MGRA Mix,dMGRAMix,"np.where(dMGRADUDen+dMGRAEmpDen > 0, (dMGRADUDen*dMGRAEmpDen)/(dMGRADUDen+dMGRAEmpDen),0)",
Origin MGRA Dwelling Unit Density Normalized by Average in Bike Estimation Sample,oMGRADUDenNorm_bike,oMGRADUDen/6.77,
Origin MGRA Employment Density Normalized by Average in Bike Estimation Sample,oMGRAEmpDenNorm_bike,oMGRAEmpDen/6.47,
Origin MGRA Dwelling Unit Density Normalized by Average in Walk Estimation Sample,oMGRADUDenNorm_walk,oMGRADUDen/7.18,
Origin MGRA Total Intersections Normalized by Average in Walk Estimation Sample,oMGRATotIntNorm_walk,oMGRATotInt/56.19,
Destination MGRA Employment Density Normalized by Average in Walk Estimation Sample,dMGRAEmpDenNorm_walk,dMGRAEmpDen/13.16,
Normalized Landuse Variable Sum [Origin Employment + DU],LUVarsNormalized_bike,oMGRADUDenNorm_bike + oMGRAEmpDenNorm_bike,
Normalized Landuse Variable Sum [Origin Intersection + DU],LUVarsNormalized_walk,oMGRADUDenNorm_walk + oMGRATotIntNorm_walk,
"Tour duration, in hours",tourDuration,df.duration/2,
#Parking calculations,,,
new daily parking cost with reimbursement,parkingCostDayDollars,"reindex(land_use.exp_daily, destination)",
new hourly parking cost with reimbursement,parkingCostHourDollars,"reindex(land_use.exp_hourly, destination)",
daily cost converted to cents,parkingCostDay,parkingCostDayDollars*100,
hourly cost converted to cents,parkingCostHour,parkingCostHourDollars*100,
Effective parking cost applied to tour purpose,parkingCost,"np.minimum(parkingCostDay, parkingCostHour * tourDuration)",
#Origin Terminal Time,oTermTime,df.PTazTerminalTime,
#Destination Terminal Time,dTermTime,df.ATazTerminalTime,
placeholder Origin Terminal Time,oTermTime,0,
placeholder Destination Terminal Time,dTermTime,0,
#,,,
,walk_time_skims_out,od_skims['walkTime'],
assuming walktime symmetry,walk_time_skims_inb,od_skims['walkTime'],
,bike_time_skims_out,od_skims['BIKE_LOGSUM'],
assuming biketime symmetry,bike_time_skims_inb,od_skims['BIKE_LOGSUM'],
#,,,
bike logsum inbound,bikeLSI,od_skims['BIKE_LOGSUM'],
bike logsum outbound (same as inbound),bikeLSO,od_skims['BIKE_LOGSUM'],
bike availability,bikeLogsumThreshold,(bikeLSI + bikeLSO) < -999,
#bike time threshold,bikeTimeThreshold,(bike_time_skims_out < max_bike_time) & (bike_time_skims_inb < max_bike_time) & (bike_time_skims_out > 0) & (bike_time_skims_inb > 0),
bike time threshold,bikeTimeThreshold,"np.where((bike_time_skims_out + bike_time_skims_inb < max_bike_time) & (bike_time_skims_out > 0) & (bike_time_skims_inb > 0), 1, 0)",
bike availability,bikeAvailable,"np.where(bikeLogsumThreshold*bikeTimeThreshold==1, 1, 0)",
#walk availability,walkAvailable,"np.where(walk_time_skims_out < max_walk_time, 1,0) * np.where(walk_time_skims_inb < max_walk_time, 1,0)",
walk availability,walkAvailable,"np.where((walk_time_skims_out + walk_time_skims_inb < max_walk_time) & (walk_time_skims_out > 0) & (walk_time_skims_inb > 0), 1,0)",
walk transit available,walkTransitAvailable,(odt_skims['WALK_MIX_TOTALIVTT'] > 0),
placeholder,walkTransitAvailable,1,
#,,,
"Cost factor for shared 2 tours, 1/(2^0.8)",costFactorS2,1,
"Cost factor for shared 3+ tours, 1/(3.5^0.8)",costFactorS3,1,
#,,,
,origin,df.origin if 'origin' in df.columns else df.home_zone_id,
,destination,df.destination if 'destination' in df.columns else df.alt_dest,
#access egress distances,,,
,origin_local_dist,"reindex(land_use.walk_dist_local_bus, origin)",
,origin_prm_dist,"reindex(land_use.walk_dist_premium_transit, origin)",
,origin_mix_dist,"np.minimum(origin_local_dist, origin_prm_dist)",
,origin_micro_local_dist,"reindex(land_use.micro_dist_local_bus, origin)",
,origin_micro_prm_dist,"reindex(land_use.micro_dist_premium_transit, origin)",
,origin_micro_mix_dist,"np.minimum(origin_micro_local_dist, origin_micro_prm_dist)",
,dest_local_dist,"reindex(land_use.walk_dist_local_bus, destination)",
,dest_prm_dist,"reindex(land_use.walk_dist_premium_transit, destination)",
,dest_mix_dist,"np.minimum(dest_local_dist, dest_prm_dist)",
,dest_micro_local_dist,"reindex(land_use.micro_dist_local_bus, destination)",
,dest_micro_prm_dist,"reindex(land_use.micro_dist_premium_transit, destination)",
,dest_micro_mix_dist,"np.minimum(dest_micro_local_dist, dest_micro_prm_dist)",
#access egress times,,,
,origin_loc_time,origin_local_dist * 60/walkSpeed,
,origin_prm_time,origin_prm_dist * 60/walkSpeed,
,origin_mix_time,origin_mix_dist * 60/walkSpeed,
,dest_loc_time,dest_local_dist * 60/walkSpeed,
,dest_prm_time,dest_prm_dist * 60/walkSpeed,
,dest_mix_time,dest_mix_dist * 60/walkSpeed,
#,,,
,walk_LOC_available,(origin_local_dist<=1)&(dest_local_dist<=1)&(odt_skims['WALK_LOC_TOTALIVTT'] > 0),
,walk_PRM_available,(origin_prm_dist<=1.2)&(dest_mix_dist<=1.2)&(odt_skims['WALK_PRM_TOTALIVTT'] > 0),
,walk_MIX_available,(origin_mix_dist<=1.2)&(dest_mix_dist<=1.2)&(odt_skims['WALK_MIX_TOTALIVTT'] > 0)&(odt_skims['WALK_MIX_XFERS']>0),
# Microtransit and NEV,,,
microtransit available at origin,microtransit_orig,"reindex(land_use.microtransit, df[orig_col_name])",
microtransit available at destination,microtransit_dest,"reindex(land_use.microtransit, df[dest_col_name])",
microtransit operating at time of tour,microtransit_operating,True,
microtransit available,microtransit_available,(microtransit_orig > 0) & (microtransit_orig == microtransit_dest) & (s3_dist_skims_out < microtransitMaxDist) & (s3_dist_skims_inb < microtransitMaxDist) & microtransit_operating,
microtransit direct time,microtransit_direct_time,"np.maximum(s3_dist_skims_out/microtransitSpeed*60, s3_time_skims_out) + np.maximum(s3_dist_skims_inb/microtransitSpeed*60, s3_time_skims_inb)",
microtransit total time,microtransit_time,"np.maximum(microtransit_direct_time + microtransitDiversionConstant, microtransitDiversionFactor*microtransit_direct_time)",
nev available at origin,nev_orig,"reindex(land_use.nev, df[orig_col_name])",
nev available at destination,nev_dest,"reindex(land_use.nev, df[dest_col_name])",
nev operating at time of tour,nev_operating,True,
nev available,nev_available,(nev_orig > 0) & (nev_orig == nev_dest) & (s3_dist_skims_out < nevMaxDist) & (s3_dist_skims_inb < nevMaxDist) & nev_operating,
nev direct time,nev_direct_time,"np.maximum(s3_dist_skims_out/nevSpeed*60, s3_time_skims_out) + np.maximum(s3_dist_skims_inb/nevSpeed*60, s3_time_skims_inb)",
nev total time,nev_time,"np.maximum(nev_direct_time + nevDiversionConstant, nevDiversionFactor*nev_direct_time)",
# Microtransit and NEV egress from transit,,,
microtransit egress from local available,microtransit_local_egress_available,(microtransit_dest>0) & (dest_micro_local_dist>maxWalkIfMTAccessAvailable) & (dest_micro_local_dist<microtransitMaxDist) & microtransit_operating,
microtransit direct egress from local time,microtransit_direct_local_egress_time,"(dest_micro_local_dist/microtransitSpeed*60) + (dest_micro_local_dist/microtransitSpeed*60)",
microtransit egress from local time,microtransit_local_egress_time,"np.maximum(microtransit_direct_local_egress_time + microtransitDiversionConstant, microtransitDiversionFactor*microtransit_direct_local_egress_time)",
nev egress from local available,nev_local_egress_available,(nev_dest>0) & (dest_micro_local_dist>maxWalkIfMTAccessAvailable) & (dest_micro_local_dist<nevMaxDist) & nev_operating,
nev direct egress from local time,nev_direct_local_egress_time,"(dest_micro_local_dist/nevSpeed*60) + (dest_micro_local_dist/nevSpeed*60)",
nev egress from local time,nev_local_egress_time,"np.maximum(nev_direct_local_egress_time + nevDiversionConstant, nevDiversionFactor*nev_direct_local_egress_time)",
#,,,
microtransit egress from premium available,microtransit_prm_egress_available,(microtransit_dest>0) & (dest_micro_prm_dist>maxWalkIfMTAccessAvailable) & (dest_micro_prm_dist<microtransitMaxDist) & microtransit_operating,
microtransit direct egress from premium time,microtransit_direct_prm_egress_time,"(dest_micro_prm_dist/microtransitSpeed*60) + (dest_micro_prm_dist/microtransitSpeed*60)",
microtransit egress from premium time,microtransit_prm_egress_time,"np.maximum(microtransit_direct_prm_egress_time + microtransitDiversionConstant, microtransitDiversionFactor*microtransit_direct_prm_egress_time)",
nev egress from premium available,nev_prm_egress_available,(nev_dest>0) & (dest_micro_prm_dist>maxWalkIfMTAccessAvailable) & (dest_micro_prm_dist<nevMaxDist) & nev_operating,
nev direct egress from premium time,nev_direct_prm_egress_time,"(dest_micro_prm_dist/nevSpeed*60) + (dest_micro_prm_dist/nevSpeed*60)",
nev egress from premium time,nev_prm_egress_time,"np.maximum(nev_direct_prm_egress_time + nevDiversionConstant, nevDiversionFactor*nev_direct_prm_egress_time)",
#,,,
microtransit egress from mixed available,microtransit_mix_egress_available,(microtransit_dest>0) & (dest_micro_mix_dist>maxWalkIfMTAccessAvailable) & (dest_micro_mix_dist<microtransitMaxDist) & microtransit_operating,
microtransit direct egress from mixed time,microtransit_direct_mix_egress_time,"(dest_micro_mix_dist/microtransitSpeed*60) + (dest_micro_mix_dist/microtransitSpeed*60)",
microtransit egress from mixed time,microtransit_mix_egress_time,"np.maximum(microtransit_direct_mix_egress_time + microtransitDiversionConstant, microtransitDiversionFactor*microtransit_direct_mix_egress_time)",
nev egress from mixed available,nev_mix_egress_available,(nev_dest>0) & (dest_micro_mix_dist>maxWalkIfMTAccessAvailable) & (dest_micro_mix_dist<nevMaxDist) & nev_operating,
nev direct egress from mixed time,nev_direct_mix_egress_time,"(dest_micro_mix_dist/nevSpeed*60) + (dest_micro_mix_dist/nevSpeed*60)",
nev egress from mixed time,nev_mix_egress_time,"np.maximum(nev_direct_mix_egress_time + nevDiversionConstant, nevDiversionFactor*nev_direct_mix_egress_time)",
# Additional transfers from microtransit and NEV,,,
microtransit/nev egress transfer,mtnev_egr_xfer,microtransit_local_egress_available | microtransit_prm_egress_available | microtransit_mix_egress_available | nev_local_egress_available | nev_prm_egress_available | nev_mix_egress_available,
# commuter rail constants based on commuter rail IVTT,,,
,wlk_prm_out_cr_asc,"(-1.0) * (np.minimum(odt_skims['WALK_PRM_CMRIVTT'],60) + np.where(odt_skims['WALK_PRM_CMRIVTT']>40,(np.minimum(odt_skims['WALK_PRM_CMRIVTT'],60)-40)*0.6,0))",
,wlk_prm_inb_cr_asc,"(-1.0) * (np.minimum(dot_skims['WALK_PRM_CMRIVTT'],60) + np.where(dot_skims['WALK_PRM_CMRIVTT']>40,(np.minimum(dot_skims['WALK_PRM_CMRIVTT'],60)-40)*0.6,0))",
,wlk_mix_out_cr_asc,"(-1.0) * (np.minimum(odt_skims['WALK_MIX_CMRIVTT'],60) + np.where(odt_skims['WALK_MIX_CMRIVTT']>40,(np.minimum(odt_skims['WALK_MIX_CMRIVTT'],60)-40)*0.6,0))",
,wlk_mix_inb_cr_asc,"(-1.0) * (np.minimum(dot_skims['WALK_MIX_CMRIVTT'],60) + np.where(dot_skims['WALK_MIX_CMRIVTT']>40,(np.minimum(dot_skims['WALK_MIX_CMRIVTT'],60)-40)*0.6,0))",
# Note: Hyperloop not implemented in ASC calculations since we arent skimming hyperloop IVTT,,,
,wlk_prm_out_asc,"np.where(odt_skims['WALK_PRM_CMRIVTT'] > 10, wlk_prm_out_cr_asc,np.where(odt_skims['WALK_PRM_LRTIVTT']>0,lrt_equiv_asc,np.where(odt_skims['WALK_PRM_BRTIVTT']>0,brt_equiv_asc,np.where(odt_skims['WALK_PRM_EXPIVTT']+odt_skims['WALK_PRM_LTDEXPIVTT'] > 0, eb_equiv_asc,0))))",
,wlk_prm_inb_asc,"np.where(dot_skims['WALK_PRM_CMRIVTT'] > 10, wlk_prm_inb_cr_asc,np.where(dot_skims['WALK_PRM_LRTIVTT']>0,lrt_equiv_asc,np.where(dot_skims['WALK_PRM_BRTIVTT']>0,brt_equiv_asc,np.where(odt_skims['WALK_PRM_EXPIVTT']+dot_skims['WALK_PRM_LTDEXPIVTT'] > 0, eb_equiv_asc,0))))",
,wlk_mix_out_max_asc,"np.where(odt_skims['WALK_MIX_CMRIVTT'] > 10, wlk_mix_out_cr_asc,np.where(odt_skims['WALK_MIX_LRTIVTT']>0,lrt_equiv_asc,np.where(odt_skims['WALK_MIX_BRTIVTT']>0,brt_equiv_asc,np.where(odt_skims['WALK_PRM_EXPIVTT']+odt_skims['WALK_MIX_LTDEXPIVTT']> 0, eb_equiv_asc,0))))",
,wlk_mix_inb_max_asc,"np.where(dot_skims['WALK_MIX_CMRIVTT'] > 10, wlk_mix_inb_cr_asc,np.where(dot_skims['WALK_MIX_LRTIVTT']>0,lrt_equiv_asc,np.where(dot_skims['WALK_MIX_BRTIVTT']>0,brt_equiv_asc,np.where(odt_skims['WALK_PRM_EXPIVTT']+dot_skims['WALK_MIX_LTDEXPIVTT']> 0, eb_equiv_asc,0))))",
# reduce by 50% if bus transfer and constant is positive (PRM has no LB service),,,
,wlk_mix_out_asc,"np.where((wlk_mix_out_max_asc > 0) & (odt_skims['WALK_MIX_BUSIVTT'] > 0), 0.5 * wlk_mix_out_max_asc, wlk_mix_out_max_asc)",
,wlk_mix_inb_asc,"np.where((wlk_mix_inb_max_asc > 0) & (dot_skims['WALK_MIX_BUSIVTT'] > 0), 0.5 * wlk_mix_inb_max_asc, wlk_mix_inb_max_asc)",
# reduce by 50% if transfers happen between cmr and other prm lines,,,
,wlk_prm_out_asc,"np.where((wlk_prm_out_asc > 0) & (odt_skims['WALK_PRM_XFERS'] > 0), 0.5 * wlk_prm_out_asc, wlk_prm_out_asc)",
,wlk_prm_inb_asc,"np.where((wlk_prm_inb_asc > 0) & (dot_skims['WALK_PRM_XFERS'] > 0), 0.5 * wlk_prm_inb_asc, wlk_prm_inb_asc)",