Description,Target,Expression,
,is_joint,(df.number_of_participants > 1),
,is_indiv,(df.number_of_participants == 1),
,is_atwork_subtour,~df.parent_tour_id.isnull(),
#,,,
#,,,
#,,estimation_larch,
,ivot,1.0 / df.value_of_time,
#,,,
,demographic_segment,df.income_segment.map(TVPB_demographic_segments_by_income_segment),
,dest_density_index,"reindex(land_use.density_index, df[dest_col_name])",
#,,,
#,,,
# #,,develop,
# ,c_cost,(0.60 * c_ivt) / df.value_of_time,
# #,,,
# # TVPB,,,
# #,,,
# ,demographic_segment,df.income_segment.map(TVPB_demographic_segments_by_income_segment),
# ,c_ivt_for_segment,"np.where(demographic_segment==C_LOW_INCOME_SEGMENT_ID,c_ivt_low_income, c_ivt_high_income)",
# ,c_cost_for_segment,"np.where(demographic_segment==C_LOW_INCOME_SEGMENT_ID,c_cost_low_income, c_cost_high_income)",
#,,,
#,,,
#atwork subtours,,,
#FIXME tripModeChoice uec wrongly conflates these with tour_mode_is_bike?,,,
,parent_tour_mode,"reindex(tours.tour_mode, df.parent_tour_id).fillna('')",
,work_tour_is_SOV,"parent_tour_mode.isin(['DRIVEALONEFREE','DRIVEALONEPAY'])",
,work_tour_is_bike,parent_tour_mode=='BIKE',
#,,,
,i_tour_mode,df.tour_mode.map(I_MODE_MAP),
,tour_mode_is_SOV,i_tour_mode.isin(I_SOV_MODES),
,tour_mode_is_auto,i_tour_mode.isin(I_AUTO_MODES),
,tour_mode_is_walk,i_tour_mode == I_WALK_MODE,
,tour_mode_is_bike,i_tour_mode == I_BIKE_MODE,
,tour_mode_is_walk_transit,i_tour_mode.isin(I_WALK_TRANSIT_MODES),
,tour_mode_is_drive_transit,i_tour_mode.isin(I_DRIVE_TRANSIT_MODES),
,tour_mode_is_ride_hail,i_tour_mode.isin(I_RIDE_HAIL_MODES),
#,,,
,inbound,~df.outbound,
,first_trip,df.trip_num == 1,
,last_trip,df.trip_num == df.trip_count,
origin terminal time not counted at home,_origin_terminal_time,"np.where(df.outbound & first_trip, 0, reindex(land_use.TERMINAL, df[ORIGIN]))",
dest terminal time not counted at home,_dest_terminal_time,"np.where(inbound & last_trip, 0, reindex(land_use.TERMINAL, df[DESTINATION]))",
,total_terminal_time,_origin_terminal_time + _dest_terminal_time,
#,,,
,free_parking_available,(df.tour_type == 'work') & df.free_parking_at_work,
,dest_hourly_peak_parking_cost,"reindex(land_use.PRKCST, df[DESTINATION])",
,origin_hourly_peak_parking_cost,"reindex(land_use.PRKCST, df[ORIGIN])",
,origin_duration,"np.where(first_trip, np.where(inbound,df.duration * ~free_parking_available,0), 1)",
,dest_duration,"np.where(last_trip, np.where(inbound, df.duration * ~free_parking_available, 0), 1)",
,origin_parking_cost,origin_duration*origin_hourly_peak_parking_cost,
,dest_parking_cost,dest_duration*dest_hourly_peak_parking_cost,
,total_parking_cost,(origin_parking_cost + dest_parking_cost) / 2.0,
,trip_topology,"np.where(df.outbound, reindex(land_use.TOPOLOGY, df[DESTINATION]), reindex(land_use.TOPOLOGY, df[ORIGIN]))",
,density_index,"np.where(df.outbound, reindex(land_use.density_index, df[DESTINATION]), reindex(land_use.density_index, df[ORIGIN]))",
,origin_density_index,"np.where(df.outbound, reindex(land_use.density_index, df[ORIGIN]), reindex(land_use.density_index, df[DESTINATION]))",
# FIXME no transit subzones so all zones short walk to transit,,,
,_walk_transit_origin,TRUE,
,_walk_transit_destination,TRUE,
,walk_transit_available,_walk_transit_origin & _walk_transit_destination,
,drive_transit_available,"np.where(df.outbound, _walk_transit_destination, _walk_transit_origin) & (df.auto_ownership > 0)",
,origin_walk_time,shortWalk*60/walkSpeed,
,destination_walk_time,shortWalk*60/walkSpeed,
# RIDEHAIL,,,
,origin_density_measure,"(reindex(land_use.TOTPOP, df[orig_col_name]) + reindex(land_use.TOTEMP, df[orig_col_name])) / (reindex(land_use.TOTACRE, df[orig_col_name]) / 640)",
,dest_density_measure,"(reindex(land_use.TOTPOP, df[dest_col_name]) + reindex(land_use.TOTEMP, df[dest_col_name])) / (reindex(land_use.TOTACRE, df[dest_col_name]) / 640)",
,origin_density,"pd.cut(origin_density_measure, bins=[-np.inf, 500, 2000, 5000, 15000, np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,dest_density,"pd.cut(dest_density_measure, bins=[-np.inf, 500, 2000, 5000, 15000, np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,Walk - Origin Mix,"origin_density.map({k: v for k, v in Taxi_waitTime_mean.items()})", but of the underlying normal distribution it is derived from
,origin_zone_taxi_wait_time_sd,"origin_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
,dest_zone_taxi_wait_time_mean,dMGRAEmpDen,
,dest_zone_taxi_wait_time_sd,"dest_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
# ,, Note that the mean and standard deviation are not the values for the distribution itself,
,origTaxiWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_taxi_wait_time_mean, sigma=origin_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destTaxiWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_taxi_wait_time_mean, sigma=dest_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_singleTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,origin_zone_singleTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,dest_zone_singleTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,dest_zone_singleTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,origSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_singleTNC_wait_time_mean, sigma=origin_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_singleTNC_wait_time_mean, sigma=dest_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_sharedTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,origin_zone_sharedTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,dest_zone_sharedTNC_wait_time_mean,"max((200+(-133 * sov_dist_skims)),0) * time_factor",
,dest_zone_sharedTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,origSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_sharedTNC_wait_time_mean, sigma=origin_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_sharedTNC_wait_time_mean, sigma=dest_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,totalWaitTaxi,origTaxiWaitTime + destTaxiWaitTime,
,totalWaitSingleTNC,origSingleTNCWaitTime + destSingleTNCWaitTime,
,totalWaitSharedTNC,origSharedTNCWaitTime + destSharedTNCWaitTime,
#,,,
,_free_parking_available,(df.tour_type == 'work') & df.free_parking_at_work if _DF_IS_TOUR else False,
,_dest_hourly_peak_parking_cost,"reindex(land_use.PRKCST, df[dest_col_name])",
,_dest_hourly_offpeak_parking_cost,"reindex(land_use.OPRKCST, df[dest_col_name])",
,_hourly_peak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_peak_parking_cost)",
,_hourly_offpeak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_offpeak_parking_cost)",
,daily_parking_cost,"np.where(is_mandatory, _hourly_peak_parking_cost * df.duration, _hourly_offpeak_parking_cost * df.duration)",
# cost coef,,,
,income_exponent,"np.where(df.tour_type == 'work', 0.6, 0.5)",
,c_cost,"(coef_income) /(max(df.income,1000)**income_exponent)",
# ivt coef,,,
,time_factor,"np.where(df.tour_type=='work', df.time_factor_work, df.time_factor_nonwork)",
,c_ivt,coef_ivt * time_factor,
#,,,
,vot_da,coef_ivt / coef_cost * 0.6,
,vot_s2,vot_da / cost_share_s2,
,vot_s3,vot_da / cost_share_s3,
,_vot_bin_da,"np.where(vot_da < vot_threshold_low, 1, np.where(vot_da < vot_threshold_med, 2, 3))",
,_vot_bin_s2,"np.where(vot_s2 < vot_threshold_low, 1, np.where(vot_s2 < vot_threshold_med, 2, 3))",
,_vot_bin_s3,"np.where(vot_s3 < vot_threshold_low, 1, np.where(vot_s3 < vot_threshold_med, 2, 3))",
#vot-indexed skims,,,
DA skim based on Transponder ownership,da_dist_skims,"(np.where(df.ownsTransponder==1, odt_skims['SOV_TR_L_DIST'], odt_skims['SOV_NT_L_DIST']) * (_vot_bin_da == 1)) + (np.where(df.ownsTransponder==1, odt_skims['SOV_TR_M_DIST'], odt_skims['SOV_NT_M_DIST']) * (_vot_bin_da == 2)) + (np.where(df.ownsTransponder==1, odt_skims['SOV_TR_H_DIST'], odt_skims['SOV_NT_H_DIST']) * (_vot_bin_da == 3))",
,da_cost_skims,"(np.where(df.ownsTransponder==1, odt_skims['SOV_TR_L_TOLLCOST'], odt_skims['SOV_NT_L_TOLLCOST']) * (_vot_bin_da == 1)) + (np.where(df.ownsTransponder==1, odt_skims['SOV_TR_M_TOLLCOST'], odt_skims['SOV_NT_M_TOLLCOST']) * (_vot_bin_da == 2)) + (np.where(df.ownsTransponder==1, odt_skims['SOV_TR_H_TOLLCOST'], odt_skims['SOV_NT_H_TOLLCOST']) * (_vot_bin_da == 3))",
,da_time_skims,"(np.where(df.ownsTransponder==1, odt_skims['SOV_TR_L_TIME'], odt_skims['SOV_NT_L_TIME']) * (_vot_bin_da == 1)) + (np.where(df.ownsTransponder==1, odt_skims['SOV_TR_M_TIME'], odt_skims['SOV_NT_M_TIME']) * (_vot_bin_da == 2)) + (np.where(df.ownsTransponder==1, odt_skims['SOV_TR_H_TIME'], odt_skims['SOV_NT_H_TIME']) * (_vot_bin_da == 3))",
,da_rel_skims,(((odt_skims['SOV_NT_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['SOV_NT_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['SOV_NT_H_REL']) * (_vot_bin_da == 3))),
,s2_dist_skims,(((odt_skims['HOV2_L_DIST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_DIST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_DIST']) * (_vot_bin_s2 == 3))),
,s2_cost_skims,(((odt_skims['HOV2_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s2_time_skims,(((odt_skims['HOV2_L_TIME']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_TIME']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_TIME']) * (_vot_bin_s2 == 3))),
,s2_rel_skims,(((odt_skims['s2_NT_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['s2_NT_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['s2_NT_H_REL']) * (_vot_bin_da == 3))),
,s3_dist_skims,(((odt_skims['HOV3_L_DIST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV3_M_DIST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV3_H_DIST']) * (_vot_bin_s2 == 3))),
,s3_cost_skims,(((odt_skims['HOV3_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV3_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV3_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s3_time_skims,(((odt_skims['HOV3_L_TIME']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV3_M_TIME']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV3_H_TIME']) * (_vot_bin_s2 == 3))),
,s3_rel_skims,(((odt_skims['s3_NT_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['s3_NT_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['s3_NT_H_REL']) * (_vot_bin_da == 3))),
,walk_time_skims,od_skims['walkTime'],
"# cte by purpose; some not used in the model, but kept since they are defined in the java version",,,
First wait time coefficient,c_fwt,"np.where(df.trip_purp=='univ', 1.94, 1.5) ",
Walk access time coefficient,c_wacc,"np.where(df.trip_purp=='work', 1.88*0.8333, np.where(df.trip_purp=='univ', 1.60, np.where(df.trip_purp=='school', 3.75, np.where(df.trip_purp=='maint',1.25, np.where(df.trip_purp=='disc', 1.44, 1.67))))) ",
Walk egress time coefficient,c_wegr,"np.where(df.trip_purp=='work', 1.5, np.where(df.trip_purp=='univ', 1.94, np.where(df.trip_purp=='school', 2.0, np.where(df.trip_purp=='maint',1.7, np.where(df.trip_purp=='disc', 1.83, 1.5))))) ",
Walk auxilliary time coefficient,c_waux,"np.where(df.trip_purp=='work', 1.5, np.where(df.trip_purp=='univ', 1.94, np.where(df.trip_purp=='school', 2.0, np.where(df.trip_purp=='maint',1.7, np.where(df.trip_purp=='disc', 1.83, 1.5))))) ",
Drive access time coefficient,c_dtim,"np.where(df.trip_purp=='work', 1.88, np.where(df.trip_purp=='univ', 1.60, np.where(df.trip_purp=='school', 0.76, np.where(df.trip_purp=='maint',1.5, np.where(df.trip_purp=='disc', 1.5, 2.0))))) ",
Transfer penalty - non-PNR modes,c_xfers,5 * c_ivt,
Transfer penalty - PNR,c_xfers_pnr,15 * c_ivt,
Bike mode time coefficient,c_bikeTime,c_ivt * 3.075,
,c_rel,"np.where((df.trip_purp=='work')&(df.inbound==0), 14, 12)",
DistanceToCoast,DistancetoCoast,milestocoast,
#,,,
Household autos,autos,df.autos,
Number of adults (age 18+) in household,adults,df.adults,
Household size (number of persons),hhSize,df.hhSize,
Person age,age,df.age,
Person is female,female,df.female,
Household income (in dollars),income,df.incomeInDollars,
Female in party,femaleInParty,df.femaleInParty,
Male in party,maleInParty,df.maleInParty,
"Result of transponder ownership model (1=owns, 0=not)",ownsTransponder,df.transponderOwnership,
Use AV coefficients for tour,useAV,df.useOwnedAV,
Auto IVT Factor,autoIVTFactor,"np.where(useAV==0,1.0,autoIVTFactorAV)",
Auto Parking Cost Factor,autoParkingCostFactor,"np.where(useAV==0,1.0,autoParkingCostFactorAV)",
Auto CPM Factor,autoCPMFactor,"np.where(useAV==0,1.0,autoCostPerMileFactorAV)",
Auto Terminal Time Factor,autoTermTimeFactor,"np.where(useAV==0,1.0,autoTerminalTimeFactorAV)",
MinimumAgeDriveAlone,minimumAgeDA,"np.where(useAV==0,16,minAgeDriveAloneAV)",
totalWaitTaxi,WaitTimeTaxi,df.WaitTimeTaxi,
totalWaitSingleTNC,waitTimeSingleTNC,df.waitTimeSingleTNC,
totalWaitSharedTNC,waitTimeSharedTNC,df.waitTimeSharedTNC,
#,,,
Zero auto households,zeroAutoHH,"np.where(autos==0,1,0)",
Auto deficient household (more adults than autos),autoDeficientHH,"np.where(autos<adults,1,0) * (np.where(zeroAutoHH,0,1))",
Auto sufficient household (enough autos for each adult),autoSufficientHH,"np.where(autos>=adults,1,0) * (np.where(zeroAutoHH,0,1))",
Time of day for outbound trip,timeOutbound,df.timeOutbound,
Time of day for inbound trip,timeInbound,df.timeInbound,
"Trip departure interval (1=4:30am, 2=5:00am, … , 39=11:30pm, 40=midnight)",timeTrip,df.timeTrip,
Joint tour,jointTour,df.tourCategoryJoint,
Number of participants in joint tour,numberOfParticipantsInJointTour,df.numberOfParticipantsInJointTour * jointTour,
Individual tour,indivTour,1 * (jointTour==0),
Number of stops - outbound direction,outStops,df.outboundStops,
Number of stops - return direction,retStops,df.returnStops,
Total stops on tour,totStops,outStops + retStops,
First trip of tour,firstTrip,df.firstTrip,
Last trip of tour,lastTrip,df.lastTrip,
First leg of multi-stop outbound,firstOfMultipleTrips,firstTrip *outStops,
Last leg of multi-stop return,lastofMultipleTrips,lastTrip * retStops,
Flag for setting availability of auto modes for drive-transit access/egress trip segments,autoAllowedForDriveTransit,df.autoModeAllowedForTripSegment,
Flag for setting availability of walk mode for drive-transit access/egress trip segments,walkAllowedForDriveTransit,df.walkModeAllowedForTripSegment,
Tour mode is drive-alone,tourDA,df.tourModeIsDA,
Tour mode is shared-2,tourS2,df.tourModeIsS2,
Tour mode is shared-3+,tourS3,df.tourModeIsS3,
Tour mode is walk,tourWalk,df.tourModeIsWalk,
Tour mode is bike,tourBike,df.tourModeIsBike,
Tour mode is walk-transit,tourWTran,df.tourModeIsWTran,
Tour mode is PNR-transit,tourPNR,df.tourModeIsPNR,
Tour mode is KNR-transit,tourKNR,df.tourModeIsKNR,
Tour mode is TNR-transit,tourTNR,df.tourModeIsTncTransit,
Tour mode is MaaS,tourMaaS,df.tourModeIsMaas,
Origin MGRA Dwelling Unit Density,oMGRADUDen,df.oDUDen,
Origin MGRA Employment Density,oMGRAEmpDen,df.oEmpDen,
Origin MGRA Total Intersections,oMGRATotInt,df.oTotInt,
Destination MGRA Dwelling Unit Density,dMGRADUDen,df.dDUDen,
Destination MGRA Employment Density,dMGRAEmpDen,df.dEmpDen,
Destination MGRA Total Intersections,dMGRATotInt,df.dTotInt,
Origin MGRA Mix,oMGRAMix,"(oMGRADUDen*oMGRAEmpDen)/(oMGRADUDen+oMGRAEmpDen) *np.where(oMGRADUDen+oMGRAEmpDen > 0,1,0)",
Destination MGRA Mix,dMGRAMix,"(dMGRADUDen*dMGRAEmpDen)/(dMGRADUDen+dMGRAEmpDen)*np.where(dMGRADUDen+dMGRAEmpDen > 0,1,0)",
"# again many are not used, but nevertheless defined in the java version",,,
"Tour duration, in hours",tourDuration,(timeInbound - timeOutbound)/2,
persontype,personType,df.personType,
new reimbursement amount,reimburseAmount ,df.reimburseAmount,
"new hourly parking cost with reimbursement, dollars",parkingCostDayDollars,df.dailyParkingCostTourDest,
"new daily parking cost with reimbursement, dollars",parkingCostHourDollars,df.hourlyParkingCostTourDest,
"new monthly parking cost with reimbursement, dollars",parkingCostMonthDollars,df.monthlyParkingCostTourDest,
new hourly parking cost with reimbursement,parkingCostDay,parkingCostDayDollars*100,
new daily parking cost with reimbursement,parkingCostHour,parkingCostHourDollars*100,
new monthly parking cost with reimbursement,parkingCostMonth,parkingCostMonthDollars*100,
Prim dest parking cost for full-time workers and university students,parkingCostBeforeReimbx,"min(parkingCostMonth, parkingCostDay) * indivTour*((df.personType == 1) + (df.personType == 3))",
Prim dest parking cost for full-time workers and university students,parkingCostBeforeReimb,"min(parkingCostBeforeReimbx, parkingCostHour * tourDuration) * indivTour*((df.personType == 1) + (df.personType == 3))",
Prim dest parking cost for other person types,parkingCostBeforeReimb,"min(parkingCostDay, parkingCostHour * tourDuration) * jointTour+indivTour*(1-(df.personType == 1) - (df.personType == 3))",
Reimbursement applies to this tour purpose,reimbursePurpose,1,
Effective parking cost for free parkers,parkingCostPrimDest,"np.where(indivTour*reimbursePurpose * df.freeOnsite.0,1)",
Effective parking cost for reimbursed parkers,parkingCostPrimDest,"max( (1-reimburseAmount) * parkingCostBeforeReimb, 0) * indivTour*reimbursePurpose * (1 - df.freeOnsite)",
Effective parking cost if no reimbursement applied to tour purpose,parkingCostPrimDest,parkingCostBeforeReimb * (jointTour + indivTour*(1-reimbursePurpose)),
Total trips on tour,totalTrips,totStops+2,
Indicator for trip origin is tour prim. Destination,tripOrigIsTourDest,df.tripOrigIsTourDest,
Indicator for trip destination is tour prim. Destination,tripDestIsTourDest,df.tripDestIsTourDest,
Contribution to trip parking cost from primary destination,parkCostTourDestContrib,parkingCostPrimDest/(totalTrips+2),
Hourly parking cost at trip origin,parkCostTripOrigDollars,df.hourlyParkingCostTripOrig,
Hourly parking cost at trip destination,parkCostTripDestDollars,df.hourlyParkingCostTripDest,
"Hourly parking cost at trip origin, cents",parkCostTripOrig,parkCostTripOrigDollars*100,
"Hourly parking cost at trip destination, cents",parkCostTripDest,parkCostTripDestDollars*100,
Contribution to trip parking cost from trip origin,parkCostTripOrigContrib,parkCostTripOrig*(1-firstTrip)*(1-tripOrigIsTourDest),
Contribution to trip parking cost from trip origin,parkCostTripOrigContrib,parkingCostPrimDest/(totalTrips+2) * tripOrigIsTourDest,
Contribution to trip parking cost from trip destination,parkCostTripDestContrib,parkCostTripDest * (1-lastTrip)*(1-tripDestIsTourDest),
Contribution to trip parking cost from trip destination,parkCostTripDestContrib,parkingCostPrimDest/(totalTrips+2) * tripDestIsTourDest,
Final parking cost,parkingCost,parkCostTourDestContrib + parkCostTripOrigContrib + parkCostTripDestContrib,
Origin Terminal Time,oTermTime,df.PTazTerminalTime,
Destination Terminal Time,dTermTime,df.ATazTerminalTime,
#,,,
Bike - logsum (male),bikeLogsumM,df.maleBikeLogsum,
Bike - logsum (female),bikeLogsumF,df.femaleBikeLogsum,
Bike - Mode available male,bikeAvailableM,"np.where(bikeLogsumM>-300,1,0) * maleInParty",
Bike - Mode available female,bikeAvailableF,"np.where(bikeLogsumF>-300,1,0) * femaleInParty",
Bike - joint min logsum,jointMinBikeLS,"min(bikeLogsumM,bikeLogsumF) * jointTour",
Bike - logsum,bikeLS,"if(maleInParty+femaleInParty>1,jointMinBikeLS,maleInParty*bikeLogsumM+femaleInParty*bikeLogsumF)",
#,,,
"Cost factor for shared 2 tours, 1/(2^0.8)",costFactorS2,0.57,
"Cost factor for shared 3+ tours, 1/(3.5^0.8)",costFactorS3,0.37,
#,,,
,sov_available,"(autos>0) * (age>=minimumAgeDA) * np.where((tourWalk+tourBike+tourWTran+TourKNR) > 0,0,1)",
,hov2_available,"np.where(tourDA+tourWalk+tourBike > 0,0,1)",
,hov3_available,"np.where(tourDA+tourS2+tourWalk+tourBike > 0,0,1)",
,walkAvailable,"np.where(walk_time_skims_out < max_walk_time, 1,0) * np.where(walk_time < max_walk_time_inb, 1,0)",
Bike - Mode available (account correctly for male/female existence,bikeAvailable,((1-maleInParty) + bikeAvailableM)*((1-femaleInParty) + bikeAvailableF),
,WLK_available,"np.where(df.walkSetLogSum <= -500 , 0, 1) * np.where(tourWTran + tourPNR + tourKNR==0,0,1)",
,PNR_available,"np.where(df.pnrSetLogSum <= -500 , 0, 1) * tourPNR * (autos>0) * (age>15)",
,KNR_available,"np.where(df.knrSetLogSum <= -500 , 0, 1) * tourKNR",
,SCHBUS_available,"(df.tour_type =='school') * np.where(tourDA+tourPNR > 0,0,1) ",
#,,,
walktime coef for all but atwork,c_walkTime,"np.where(df.trip_purp=='work', 2.65, np.where(df.trip_purp=='univ', 2.77, np.where(df.trip_purp=='school', 6.80, np.where(df.trip_purp=='maint', 2.35, np.where(df.trip_purp=='disc', 2.14, 0)))))",
atwork walktime coef,c_walkTime_cte,"np.where(df.trip_purp=='subtour', -0.1592596416675, 0)",
