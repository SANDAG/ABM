Description,Target,Expression,
#,,,
local,_DF_IS_TOUR,'tour_type' in df.columns,
,number_of_participants,df.number_of_participants if _DF_IS_TOUR else 1,
,is_joint,(df.tour_category=='joint') if _DF_IS_TOUR else False,
treat tours as work if tour_type not yet decided,tour_type,"df.get('tour_type', default='work')",
#,,,
# TVPB,,,
#,,,
#,demographic_segment,df.income_segment.map(TVPB_demographic_segments_by_income_segment),
#,c_ivt_for_segment,"np.where(demographic_segment==C_LOW_INCOME_SEGMENT_ID,c_ivt_low_income, c_ivt_high_income)",
#,c_cost_for_segment,"np.where(demographic_segment==C_LOW_INCOME_SEGMENT_ID,c_cost_low_income, c_cost_high_income)",
#,,,
,is_mandatory,(df.tour_category=='mandatory') if 'tour_category' in df.columns else False,
,is_joint,(df.tour_category=='joint') if 'tour_category' in df.columns else False,
,is_indiv,~is_joint,
,is_escort,(tour_type == 'escort') if _DF_IS_TOUR else False,
# Auto operating costs,,,
,is_atwork_subtour,(df.tour_category == 'atwork') if _DF_IS_TOUR else False,
,parent_tour_veh,"reindex(tours['selected_vehicle'], df['parent_tour_id']) if 'selected_vehicle' in df.columns else np.nan",
,sov_veh_option,"np.where(is_atwork_subtour, parent_tour_veh, df.get('vehicle_occup_1', np.nan))",
,sr2_veh_option,"np.where(is_atwork_subtour, parent_tour_veh, df.get('vehicle_occup_2', np.nan))",
,sr3p_veh_option,"np.where(is_atwork_subtour, parent_tour_veh, df.get('vehicle_occup_3.5', np.nan))",
,sov_auto_op_cost,"reindex(vehicles.groupby('vehicle_type')['auto_operating_cost'].mean(), pd.Series(sov_veh_option, df.index)) if 'vehicle_occup_1' in df.columns else np.nan",
,sov_auto_op_cost,"np.where(sov_auto_op_cost.isna() | (pd.Series(sov_veh_option, df.index) == 'non_hh_veh'), costPerMile, sov_auto_op_cost)",
,sr2_auto_op_cost,"reindex(vehicles.groupby('vehicle_type')['auto_operating_cost'].mean(), pd.Series(sr2_veh_option, df.index)) if 'vehicle_occup_2' in df.columns else np.nan",
,sr2_auto_op_cost,"np.where(sr2_auto_op_cost.isna() | (pd.Series(sr2_veh_option, df.index) == 'non_hh_veh'), costPerMile, sr2_auto_op_cost)",
,sr3p_auto_op_cost,"reindex(vehicles.groupby('vehicle_type')['auto_operating_cost'].mean(), pd.Series(sr3p_veh_option, df.index)) if 'vehicle_occup_3.5' in df.columns else np.nan",
,sr3p_auto_op_cost,"np.where(sr3p_auto_op_cost.isna() | (pd.Series(sr3p_veh_option, df.index) == 'non_hh_veh'), costPerMile, sr3p_auto_op_cost)",
# FIXME no transit subzones for ONE_ZONE version, so all zones short walk to transit,,
,_origin_distance_to_transit,"reindex(land_use.access_dist_transit, df[orig_col_name]) if 'access_dist_transit' in land_use else shortWalk",
,_destination_distance_to_transit,"reindex(land_use.access_dist_transit, df[dest_col_name]) if 'access_dist_transit' in land_use else shortWalk",
,walk_transit_available,(_origin_distance_to_transit > 0) & (_destination_distance_to_transit > 0),
,drive_transit_available,(_destination_distance_to_transit > 0) & (df.auto_ownership > 0),
,origin_walk_time,_origin_distance_to_transit*60/walkSpeed,
,destination_walk_time,_destination_distance_to_transit*60/walkSpeed,
# RIDEHAIL,,,
household_density calculated in annotate_landuse in acres and is converted to sq miles here,origin_density_measure,"reindex(land_use.household_density, df[orig_col_name]) / 640",
employment_density calculated in annotate_landuse in acres and is converted to sq miles here,dest_density_measure,"reindex(land_use.employment_density, df[dest_col_name]) / 640",
,origin_density,"pd.cut(origin_density_measure, bins=[-np.inf, 500, 2000, 5000, 15000, np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,dest_density,"pd.cut(dest_density_measure, bins=[-np.inf, 500, 2000, 5000, 15000, np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,origin_zone_taxi_wait_time_mean,"origin_density.map({k: v for k, v in Taxi_waitTime_mean.items()})",
,origin_zone_taxi_wait_time_sd,"origin_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
,dest_zone_taxi_wait_time_mean,"dest_density.map({k: v for k, v in Taxi_waitTime_mean.items()})",
,dest_zone_taxi_wait_time_sd,"dest_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
# ,, Note that the mean and standard deviation are not the values for the distribution itself, but of the underlying normal distribution it is derived from
,origTaxiWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_taxi_wait_time_mean, sigma=origin_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destTaxiWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_taxi_wait_time_mean, sigma=dest_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_singleTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,origin_zone_singleTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,dest_zone_singleTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,dest_zone_singleTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,origSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_singleTNC_wait_time_mean, sigma=origin_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_singleTNC_wait_time_mean, sigma=dest_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_sharedTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,origin_zone_sharedTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,dest_zone_sharedTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,dest_zone_sharedTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,origSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_sharedTNC_wait_time_mean, sigma=origin_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_sharedTNC_wait_time_mean, sigma=dest_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,totalWaitTaxi,origTaxiWaitTime + destTaxiWaitTime,
,totalWaitSingleTNC,origSingleTNCWaitTime + destSingleTNCWaitTime,
,totalWaitSharedTNC,origSharedTNCWaitTime + destSharedTNCWaitTime,
#pulling in constant,costPerMile,costPerMile,
#,,,
,_free_parking_available,(tour_type == 'work') & df.free_parking_at_work if _DF_IS_TOUR else False,
,_dest_hourly_peak_parking_cost,"reindex(land_use.hparkcost, df[dest_col_name])",
,_dest_hourly_offpeak_parking_cost,"reindex(land_use.hparkcost, df[dest_col_name])",
,_hourly_peak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_peak_parking_cost)",
,_hourly_offpeak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_offpeak_parking_cost)",
,daily_parking_cost,"np.where(is_mandatory, _hourly_peak_parking_cost * df.duration, _hourly_offpeak_parking_cost * df.duration)",
# cost coef,,,
,income_exponent,"np.where(tour_type == 'work', 0.6, 0.5)",
,c_cost,"(coef_income) /(df.income.clip(0,1000).pow(income_exponent))",
# ivt coef,,,
,time_factor,"np.where(tour_type=='work', df.time_factor_work, df.time_factor_nonwork)",
,c_ivt,coef_ivt * time_factor,
,ivot,time_factor,
#,,,
,vot_da,c_ivt / c_cost * 0.6,
,vot_s2,vot_da / cost_share_s2,
,vot_s3,vot_da / cost_share_s3,
,_vot_bin_da,"np.where(vot_da < vot_threshold_low, 1, np.where(vot_da < vot_threshold_med, 2, 3))",
,_vot_bin_s2,"np.where(vot_s2 < vot_threshold_low, 1, np.where(vot_s2 < vot_threshold_med, 2, 3))",
,_vot_bin_s3,"np.where(vot_s3 < vot_threshold_low, 1, np.where(vot_s3 < vot_threshold_med, 2, 3))",
# vot-indexed skims,,,
#,ownsTransponder,"reindex(households.transponder_ownership, df.household_id) if 'transponder_ownership' in households else 0",
,ownsTransponder,df.transponder_ownership if 'transponder_ownership' in df else 0,
#placeholder for walk time skim,ownsTransponder,1,
DA skim based on Transponder ownership,da_dist_skims_out,"(np.where(ownsTransponder==1, odt_skims['SOV_TR_L_DIST'], odt_skims['SOV_NT_L_DIST']) * (_vot_bin_da == 1)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_M_DIST'], odt_skims['SOV_NT_M_DIST']) * (_vot_bin_da == 2)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_H_DIST'], odt_skims['SOV_NT_H_DIST']) * (_vot_bin_da == 3))",
,da_dist_skims_inb,"(np.where(ownsTransponder==1, dot_skims['SOV_TR_L_DIST'], dot_skims['SOV_NT_L_DIST']) * (_vot_bin_da == 1)) + (np.where(ownsTransponder==1, dot_skims['SOV_TR_M_DIST'], dot_skims['SOV_NT_M_DIST']) * (_vot_bin_da == 2)) + (np.where(ownsTransponder==1, dot_skims['SOV_TR_H_DIST'], dot_skims['SOV_NT_H_DIST']) * (_vot_bin_da == 3))",
,da_cost_skims_out,"(np.where(ownsTransponder==1, odt_skims['SOV_TR_L_TOLLCOST'], odt_skims['SOV_NT_L_TOLLCOST']) * (_vot_bin_da == 1)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_M_TOLLCOST'], odt_skims['SOV_NT_M_TOLLCOST']) * (_vot_bin_da == 2)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_H_TOLLCOST'], odt_skims['SOV_NT_H_TOLLCOST']) * (_vot_bin_da == 3))",
,da_cost_skims_inb,"(np.where(ownsTransponder==1, dot_skims['SOV_TR_L_TOLLCOST'], dot_skims['SOV_NT_L_TOLLCOST']) * (_vot_bin_da == 1)) + (np.where(ownsTransponder==1, dot_skims['SOV_TR_M_TOLLCOST'], dot_skims['SOV_NT_M_TOLLCOST']) * (_vot_bin_da == 2)) + (np.where(ownsTransponder==1, dot_skims['SOV_TR_H_TOLLCOST'], dot_skims['SOV_NT_H_TOLLCOST']) * (_vot_bin_da == 3))",
,da_time_skims_out,"(np.where(ownsTransponder==1, odt_skims['SOV_TR_L_TIME'], odt_skims['SOV_NT_L_TIME']) * (_vot_bin_da == 1)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_M_TIME'], odt_skims['SOV_NT_M_TIME']) * (_vot_bin_da == 2)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_H_TIME'], odt_skims['SOV_NT_H_TIME']) * (_vot_bin_da == 3))",
,da_time_skims_inb,"(np.where(ownsTransponder==1, dot_skims['SOV_TR_L_TIME'], dot_skims['SOV_NT_L_TIME']) * (_vot_bin_da == 1)) + (np.where(ownsTransponder==1, dot_skims['SOV_TR_M_TIME'], dot_skims['SOV_NT_M_TIME']) * (_vot_bin_da == 2)) + (np.where(ownsTransponder==1, dot_skims['SOV_TR_H_TIME'], dot_skims['SOV_NT_H_TIME']) * (_vot_bin_da == 3))",
,da_rel_skims_out,(((odt_skims['SOV_NT_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['SOV_NT_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['SOV_NT_H_REL']) * (_vot_bin_da == 3))),
,da_rel_skims_inb,(((dot_skims['SOV_NT_L_REL']) * (_vot_bin_da == 1)) + ((dot_skims['SOV_NT_M_REL']) * (_vot_bin_da == 2)) + ((dot_skims['SOV_NT_H_REL']) * (_vot_bin_da == 3))),
,s2_dist_skims_out,(((odt_skims['HOV2_L_DIST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_DIST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_DIST']) * (_vot_bin_s2 == 3))),
,s2_dist_skims_inb,(((dot_skims['HOV2_L_DIST']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV2_M_DIST']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV2_H_DIST']) * (_vot_bin_s2 == 3))),
,s2_cost_skims_out,(((odt_skims['HOV2_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s2_cost_skims_inb,(((dot_skims['HOV2_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV2_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV2_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s2_time_skims_out,(((odt_skims['HOV2_L_TIME']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_TIME']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_TIME']) * (_vot_bin_s2 == 3))),
,s2_time_skims_inb,(((dot_skims['HOV2_L_TIME']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV2_M_TIME']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV2_H_TIME']) * (_vot_bin_s2 == 3))),
,s2_rel_skims_out,(((odt_skims['HOV2_L_REL']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_REL']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_REL']) * (_vot_bin_s2 == 3))),
,s2_rel_skims_inb,(((dot_skims['HOV2_L_REL']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV2_M_REL']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV2_H_REL']) * (_vot_bin_s2 == 3))),
,s3_dist_skims_out,(((odt_skims['HOV3_L_DIST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV3_M_DIST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV3_H_DIST']) * (_vot_bin_s2 == 3))),
,s3_dist_skims_inb,(((dot_skims['HOV3_L_DIST']) * (_vot_bin_s3 == 1)) + ((dot_skims['HOV3_M_DIST']) * (_vot_bin_s3 == 2)) + ((dot_skims['HOV3_H_DIST']) * (_vot_bin_s3 == 3))),
,s3_cost_skims_out,(((odt_skims['HOV3_L_TOLLCOST']) * (_vot_bin_s3 == 1)) + ((odt_skims['HOV3_M_TOLLCOST']) * (_vot_bin_s3 == 2)) + ((odt_skims['HOV3_H_TOLLCOST']) * (_vot_bin_s3 == 3))),
,s3_cost_skims_inb,(((dot_skims['HOV3_L_TOLLCOST']) * (_vot_bin_s3 == 1)) + ((dot_skims['HOV3_M_TOLLCOST']) * (_vot_bin_s3 == 2)) + ((dot_skims['HOV3_H_TOLLCOST']) * (_vot_bin_s3 == 3))),
,s3_time_skims_out,(((odt_skims['HOV3_L_TIME']) * (_vot_bin_s3 == 1)) + ((odt_skims['HOV3_M_TIME']) * (_vot_bin_s3 == 2)) + ((odt_skims['HOV3_H_TIME']) * (_vot_bin_s3 == 3))),
,s3_time_skims_inb,(((dot_skims['HOV3_L_TIME']) * (_vot_bin_s3 == 1)) + ((dot_skims['HOV3_M_TIME']) * (_vot_bin_s3 == 2)) + ((dot_skims['HOV3_H_TIME']) * (_vot_bin_s3 == 3))),
,s3_rel_skims_out,(((odt_skims['HOV3_L_REL']) * (_vot_bin_s3 == 1)) + ((odt_skims['HOV3_M_REL']) * (_vot_bin_s3 == 2)) + ((odt_skims['HOV3_H_REL']) * (_vot_bin_s3 == 3))),
,s3_rel_skims_inb,(((dot_skims['HOV3_L_REL']) * (_vot_bin_s3 == 1)) + ((dot_skims['HOV3_M_REL']) * (_vot_bin_s3 == 2)) + ((dot_skims['HOV3_H_REL']) * (_vot_bin_s3 == 3))),
,walk_time_skims_out,od_skims['walkTime'],
assuming walktime symmetry,walk_time_skims_inb,od_skims['walkTime'],
#placeholder for walk time skim,walk_time_skims_out,odt_skims['SOV_TR_L_DIST'] * 3 / 60,
#placeholder for walk time skim,walk_time_skims_inb,dot_skims['SOV_TR_L_DIST'] * 3 / 60,
#,,,
First wait time coefficient,c_fwt,"np.where(tour_type=='maint', 1.6, 1.5) ",
Transfer wait time coefficient,c_xwt,"np.where(tour_type=='maint', 1.6, 1.5) ",
Walk access time coefficient,c_wacc,"np.where(tour_type=='work', 1.88*0.8333, np.where(tour_type=='univ', 1.60, np.where(tour_type=='school', 3.0, np.where(tour_type=='maint',1.2, np.where(tour_type=='disc', 2.1, 1.7))))) ",
Walk egress time coefficient,c_wegr,"np.where(tour_type=='work', 1.88*0.8333, np.where(tour_type=='univ', 1.60, np.where(tour_type=='school', 3.0, np.where(tour_type=='maint',1.2, np.where(tour_type=='disc', 2.1, 1.7))))) ",
Walk auxilliary time coefficient,c_waux,"np.where(tour_type=='work', 1.88*0.8333, np.where(tour_type=='univ', 1.60, np.where(tour_type=='school', 3.0, np.where(tour_type=='maint',1.2, np.where(tour_type=='disc', 2.1, 1.7))))) ",
Drive access time coefficient,c_dtim,"np.where(tour_type=='work', 1.88, np.where(tour_type=='univ', 1.60, np.where(tour_type=='school', 0.76, np.where(tour_type=='maint',1.5, np.where(tour_type=='disc', 1.5, 2.0))))) ",
,c_walktime,"np.where(tour_type=='school', 6.8, np.where(tour_type=='maint', 2.35, np.where(tour_type=='disc', 3.0, 2.65)))",
Transfer penalty - non-PNR modes,c_xfers,5 * c_ivt,
Transfer penalty - PNR,c_xfers_pnr,15 * c_ivt,
Bike mode time coefficient,c_bikeTime,c_ivt * 3.075,
#DistanceToCoast,DistanceToCoast,milestocoast,
placeholder for undefined milestocoast,DistanceToCoast,5,
#,,,
Household autos,autos,df.auto_ownership,
Number of adults (age 18+) in household,adults,df.num_adults,
#Household size (number of persons),hhSize,df.hhsize,
Person age,age,df.age,
# Household income (in dollars),income,df.incomeInDollars,
#Use AV coefficients for tour,useAV,df.useOwnedAV,
#Auto IVT Factor,autoIVTFactor,"np.where(useAV==0,1.0,autoIVTFactorAV)",
placeholder Auto IVT Factor,autoIVTFactor,1,
#Auto Parking Cost Factor,autoParkingCostFactor,"np.where(useAV==0,1.0,autoParkingCostFactorAV)",
placeholder for missing autoParkingCostFactorAV,autoParkingCostFactor,1,
#Auto CPM Factor,autoCPMFactor,"np.where(useAV==0,1.0,autoCostPerMileFactorAV)",
placeholder for missing autoCostPerMileFactorAV,autoCPMFactor,1,
#Auto Terminal Time Factor,autoTermTimeFactor,"np.where(useAV==0,1.0,autoTerminalTimeFactorAV)",
placeholder for missing autoTerminalTimeFactorAV,autoTermTimeFactor,1,
#MinimumAgeDriveAlone,minimumAgeDA,"np.where(useAV==0,16,minAgeDriveAloneAV)",
placeholder for missing minAgeDriveAloneAV,minimumAgeDA,16,
#,,,
Zero auto households,zeroAutoHH,"np.where(autos==0,1,0)",
Auto deficient household (more adults than autos),autoDeficientHH,"np.where(autos<adults,1,0) * (np.where(zeroAutoHH,0,1))",
Auto sufficient household (enough autos for each adult),autoSufficientHH,"np.where(autos>=adults,1,0) * (np.where(zeroAutoHH,0,1))",
Joint tour,jointTour,"df.get('tour_category', default=False) == 'joint'",
# Number of participants in joint tour,numberOfParticipantsInJointTour,df.number_of_participants * jointTour,
#NOTE: this is defined in the common constants file,,,
#Individual tour,indivTour,1 * (jointTour==0),
Determining Tour Origin,origin,df.origin if 'origin' in df.columns else df.home_zone_id if 'home_zone_id' in df.columns else df.workplace_zone_id,
Determining Tour Destination,destination,df.destination if 'destination' in df.columns else df.alt_dest,
Origin MGRA Dwelling Unit Density,oMGRADUDen,"reindex(land_use.household_density,origin)",
Origin MGRA Employment Density,oMGRAEmpDen,"reindex(land_use.employment_density,origin)",
Origin MGRA Total Intersections,oMGRATotInt,"reindex(land_use.totint,origin)",
Destination MGRA Dwelling Unit Density,dMGRADUDen,"reindex(land_use.household_density,destination)",
Destination MGRA Employment Density,dMGRAEmpDen,"reindex(land_use.employment_density,destination)",
Destination MGRA Total Intersections,dMGRATotInt,"reindex(land_use.totint,destination)",
Origin MGRA Mix,oMGRAMix,"np.where(oMGRADUDen+oMGRAEmpDen > 0, (oMGRADUDen*oMGRAEmpDen)/(oMGRADUDen+oMGRAEmpDen),0)",
Destination MGRA Mix,dMGRAMix,"np.where(dMGRADUDen+dMGRAEmpDen > 0, (dMGRADUDen*dMGRAEmpDen)/(dMGRADUDen+dMGRAEmpDen),0)",
Origin MGRA Dwelling Unit Density Normalized by Average in Bike Estimation Sample,oMGRADUDenNorm_bike,oMGRADUDen/6.77,
Origin MGRA Employment Density Normalized by Average in Bike Estimation Sample,oMGRAEmpDenNorm_bike,oMGRAEmpDen/6.47,
Origin MGRA Dwelling Unit Density Normalized by Average in Walk Estimation Sample,oMGRADUDenNorm_walk,oMGRADUDen/7.18,
Origin MGRA Total Intersections Normalized by Average in Walk Estimation Sample,oMGRATotIntNorm_walk,oMGRATotInt/56.19,
Destination MGRA Employment Density Normalized by Average in Walk Estimation Sample,dMGRAEmpDenNorm_walk,dMGRAEmpDen/13.16,
Normalized Landuse Variable Sum [Origin Employment + DU],LUVarsNormalized_bike,oMGRADUDenNorm_bike + oMGRAEmpDenNorm_bike,
Normalized Landuse Variable Sum [Origin Intersection + DU],LUVarsNormalized_walk,oMGRADUDenNorm_walk + oMGRATotIntNorm_walk,
"Tour duration, in hours",tourDuration,df.duration/2,
persontype,personType,"df.ptype*np.where(indivTour,1,0)",
# Result of employer parking provision and reimbursement model,freeParkingEligibility,"df.freeParkingEligibility*np.where(indivTour,1,0)",
freeParkingEligibility placeholder,freeParkingEligibility,0,
person has free on-site parking at workplace,freeOnsite,"(freeParkingEligibility == 1)*np.where(indivTour,1,0)",
# new reimbursement amount,reimburseProportion,"df.reimburseProportion*np.where(indivTour,1,0)",
reimburseProportion placeholder,reimburseProportion,0,
new daily parking cost with reimbursement,parkingCostDayDollars,"reindex(land_use.dparkcost, destination)",
new hourly parking cost with reimbursement,parkingCostHourDollars,"reindex(land_use.hparkcost, destination)",
new monthly parking cost with reimbursement,parkingCostMonthDollars,"reindex(land_use.mparkcost, destination)",
Parking area,parkingConstrainedArea,"np.where(reindex(land_use.parkarea, destination) == 1, 1, 0)",
daily cost converted to cents,parkingCostDay,parkingCostDayDollars*100,
hourly cost converted to cents,parkingCostHour,parkingCostHourDollars*100,
monthly cost converted to cents,parkingCostMonth,parkingCostMonthDollars*100,
Tour parking cost for full-time workers and university students,parkingCostBeforeReimbx,"personType.isin([1,3]) * indivTour * np.minimum(parkingCostMonth, parkingCostDay)",
Tour parking cost for full-time workers and university students,parkingCostBeforeReimb,"personType.isin([1,3]) * indivTour * np.minimum(parkingCostBeforeReimbx, parkingCostHour * tourDuration)",
Tour parking cost for other person types,parkingCostBeforeReimb,"((~personType.isin([1,3]) * indivTour) + jointTour) * np.minimum(parkingCostDay, parkingCostHour * tourDuration)",
Reimbursement applies to this tour purpose,reimbursePurpose,1,
Effective parking cost for free parkers,parkingCost,"0 * np.where(indivTour*reimbursePurpose * freeOnsite,1,0)",
Effective parking cost for reimbursed parkers,parkingCost,"np.maximum( (1-reimburseProportion) * parkingCostBeforeReimb, 0) * np.where((indivTour*reimbursePurpose * (1 - freeOnsite)),1,0)",
Effective parking cost if no reimbursement applied to tour purpose,parkingCost,"parkingCostBeforeReimb * np.where((jointTour+indivTour*(1-reimbursePurpose)),1,0)",
#Origin Terminal Time,oTermTime,df.PTazTerminalTime,
#Destination Terminal Time,dTermTime,df.ATazTerminalTime,
placeholder Origin Terminal Time,oTermTime,0,
placeholder Destination Terminal Time,dTermTime,0,
#,,,
# Below bike info is not defined and is turned off!!,,,
Person is female,female,(df.sex == 2),
# Female in party,femaleInParty,df.femaleInParty,
# Male in party,maleInParty,df.maleInParty,
# Bike - logsum (inbound male),bikeLogsumIM,df.inboundMaleBikeLogsum,
# Bike - logsum (outbound male),bikeLogsumOM,df.outboundMaleBikeLogsum,
# Bike - logsum (inbound female),bikeLogsumIF,df.inboundFemaleBikeLogsum,
# Bike - logsum (outbound female),bikeLogsumOF,df.outboundFemaleBikeLogsum,
# Bike - Mode available male (multiplication ensures counting both directions),bikeAvailableM,"np.where(bikeLogsumIM>-300,1,0) * np.where(bikeLogsumOM>-300,1,0) * maleinParty",
# Bike - Mode available female (multiplication ensures counting both directions),bikeAvailableF,"np.where(bikeLogsumIF>-300,1,0) * np.where(bikeLogsumOF>-300,1,0) * femaleInParty",
# Bike - joint inbound logsum minimum,jointMinBikeLSI,"min(bikeLogsumIM,bikeLogsumIF) * jointTour",
# Bike - joint outbound logsum minimum,jointMinBikeLSO,"min(bikeLogsumOM,bikeLogsumOF) * jointTour",
# Bike - logsum inbound,bikeLSI,"np.where((maleInParty+femaleInParty)>1,jointMinBikeLSI,maleInParty*bikeLogsumIM+femaleInParty*bikeLogsumIF)",
# Bike - logsum outbound,bikeLSO,"np.where((maleInParty+femaleInParty)>1,jointMinBikeLSO,maleInParty*bikeLogsumOM+femaleInParty*bikeLogsumOF)",
# Bike - Mode available (account correctly for male/female existence,bikeAvailable,((1-maleInParty) + bikeAvailableM)*((1-femaleInParty) + bikeAvailableF),
bike logsum inbound,bikeLSI,od_skims['BIKE_LOGSUM'],
bike logsum outbound (same as inbound),bikeLSO,od_skims['BIKE_LOGSUM'],
bike availability,bikeAvailable,((bikeLSI + bikeLSO) > -999) & (od_skims['DIST'] < max_bike_distance),
#,,,
"Cost factor for shared 2 tours, 1/(2^0.8)",costFactorS2,0.57,
"Cost factor for shared 3+ tours, 1/(3.5^0.8)",costFactorS3,0.37,
,sov_available,(autos>0) * (age>=minimumAgeDA),
,walkAvailable,"np.where(walk_time_skims_out < max_walk_time, 1,0) * np.where(walk_time_skims_inb < max_walk_time, 1,0)",
#,WLK_available,"np.where(df.walkSetLogSum <= -999, 0, 1)",
#,PNR_available,"np.where(df.pnrSetLogSum <= -999 , 0, 1) * (autos>0) * (age>15)",
#,KNR_available,"np.where(df.knrSetLogSum <= -999 , 0, 1)",
# do we even need availability (for non-PNR) since logsum give -999 if unavailable?,,,
placeholder,WLK_available,1,
placeholder,PNR_available,1 * (autos>0) * (age>15),
placeholder,KNR_available,1,
placeholder,TNCTransit_available,1,
,SCHBUS_available,(tour_type =='school'),
#,,,
Determining Tour Origin,origin,df.origin if 'origin' in df.columns else df.home_zone_id if 'home_zone_id' in df.columns else df.workplace_zone_id,
Determining Tour Destination,destination,df.destination if 'destination' in df.columns else df.alt_dest,
#access egress times,,,
,origin_local_time,odt_skims['WALK_LOC_ACC'],
,origin_prm_time,odt_skims['WALK_PRM_ACC'],
min of local and premium dist,origin_mix_time,odt_skims['WALK_MIX_ACC'],
,dest_local_time,dot_skims['WALK_LOC_EGR'],
,dest_prm_time,dot_skims['WALK_PRM_EGR'],
,dest_mix_time,dot_skims['WALK_MIX_EGR'],
#,,,
,walk_local_available,(odt_skims['WALK_LOC_TOTALIVTT']>0) & (dot_skims['WALK_LOC_TOTALIVTT']>0) & (origin_local_time < max_local_walk_time) & (dest_local_time < max_local_walk_time),
,walk_premium_available,(odt_skims['WALK_PRM_TOTALIVTT']>0) & (dot_skims['WALK_PRM_TOTALIVTT']>0) & (origin_prm_time < max_prm_walk_time) & (dest_prm_time < max_prm_walk_time),
,walk_mix_available,(odt_skims['WALK_MIX_TOTALIVTT']>0) & (dot_skims['WALK_MIX_TOTALIVTT']>0) & (origin_mix_time < max_mix_walk_time) & (dest_mix_time < max_mix_walk_time),
,pnr_local_available,(odt_skims['PNRIN_LOC_TOTALIVTT']>0) & (dot_skims['PNROUT_LOC_TOTALIVTT']>0) & (dest_local_time < max_local_walk_time),
,pnr_premium_available,(odt_skims['PNRIN_PRM_TOTALIVTT']>0) & (dot_skims['PNROUT_PRM_TOTALIVTT']>0) & (dest_prm_time < max_prm_walk_time),
,pnr_mix_available,(odt_skims['PNRIN_MIX_TOTALIVTT']>0) & (dot_skims['PNROUT_MIX_TOTALIVTT']>0) & (dest_mix_time < max_mix_walk_time),
,knr_local_available,(odt_skims['KNRIN_LOC_TOTALIVTT']>0) & (dot_skims['KNROUT_LOC_TOTALIVTT']>0) & (dest_local_time < max_local_walk_time),
,knr_premium_available,(odt_skims['KNRIN_PRM_TOTALIVTT']>0) & (dot_skims['KNROUT_PRM_TOTALIVTT']>0) & (dest_prm_time < max_prm_walk_time),
,knr_mix_available,(odt_skims['KNRIN_MIX_TOTALIVTT']>0) & (dot_skims['KNROUT_MIX_TOTALIVTT']>0) & (dest_mix_time < max_mix_walk_time),
,tnc_local_available,(odt_skims['TNCIN_LOC_TOTALIVTT']>0) & (dot_skims['TNCOUT_LOC_TOTALIVTT']>0) & (dest_local_time < max_local_walk_time),
,tnc_premium_available,(odt_skims['TNCIN_PRM_TOTALIVTT']>0) & (dot_skims['TNCOUT_PRM_TOTALIVTT']>0) & (dest_prm_time < max_prm_walk_time),
,tnc_mix_available,(odt_skims['TNCIN_MIX_TOTALIVTT']>0) & (dot_skims['TNCOUT_MIX_TOTALIVTT']>0) & (dest_mix_time < max_mix_walk_time),
